# Created BY Simushi_Mulowa
<u>##**To-Do List CLI(Command Line) Application**##<u>
A command-line task manager with persistent file storage, built in C++.

###**Requirements To Run it:**###
-Healthy IDE
-My C++ source code file (Clean_Final_Task_3.cpp)
-Backbone.txt (optional - the program creates it for you if you don't have it)

###**Files**###
-Clean_Final_Task_3.cpp - Main program
-Backbone.txt - Data storage (format: task name, then 0=Not Done or 1=Done on next line)

##*What I Built*##
This program uses:
Vectors for dynamic task storage
Structs to organize task data
File I/O for permanent storage
Functions with reference parameters

###***Features***###
-Add tasks
-View all tasks
-Mark tasks as completed/uncompleted
-Delete tasks
-Automatic save after every operation
-Data persists between sessions

##**How to Run**##
You need to have a healthy IDE (all C++ compilers should be present such that even a simple "Hello World" should run - that's what I mean by "healthy IDE"), working smoothly.
Preferably VS Code (the most smooth) or Code::Blocks (a little complex to use), or any IDE you're comfortable with.
-You interact with the entire program via a CLI menu by choosing numbers on the menu and doing what the program tells you to do.

<img width="1262" height="717" alt="image" src="https://github.com/user-attachments/assets/57b9acad-9942-437f-ba0f-9935d1de1331" /> .


#**WHAT I LEARNED**#
    I learned how to write a program that can store user inputs and remember them after you completely close your IDE and open it back.
I learned how to use ternary operators mixed with booleans, how to write good, short boolean functions embedded with ternary operators. I learned something completely new: the Vector theory and its usage, the Structure theory and its usage. I also truly learned how the basic File System works, specifically to add long-term memory to a program as if it's an application.
    I learned how to pass variables to functions by reference and by value - I truly understood what it means. I also learned different ways of writing functions.
In the journey I also learned how to fix IDEs when they get clogged and start malfunctioning. My initial VS Code crashed and took me weeks to fix, but I couldn't. I taught myself how to use the complicated Code::Blocks from scratch, and at some point it went mad - I had to start troubleshooting the IDE itself instead of the code.
All in all, the biggest lesson I learned is ***endurance during coding.*** It's not smooth, but the spirit of not giving up is what has made me come this far to the finish line.

##**The Hardest Parts**##
###**Structures**### - The Structure theory was so difficult to understand, how it all works. I think I need to continue exposing myself to structures.

###**Vectors**### - At first it was a little easy, just like a variable that can swallow a lot of data. But the confusion came from how to make it swallow the data, how to feed it, especially using a loop. Even how to print everything it contains or make it vomit its data using a loop - it was confusing. There was a lot of new code I learned for how to control the vector. Its declaration itself was weird and spooky.

###**Booleans & Ternary Operators**### - I also faced great difficulty learning how a boolean works - not only true or false or 0 and 1. I realized I was learning it simultaneously with how ternary operators work. I never knew what was happening, so it became tough.

###**File System**### - At first it was simple, less difficult, since I like using my own abstract language to replace complex terms when learning. But the hell came in when merging the theory into the entire program so that it gains permanent memory. ***Things got wild and crazy!*** It became complicated to me, but luckily enough I made it through.

###**Functions & Parameters**### - I faced difficulty in controlling functions. The hardest part was the parameters and the variables - whether they are local or global. It kept confusing me until I got used to it at last.

###**Code Fragility**### - Lastly, I observed that the bigger the code gets, the more fragile it becomes. Mistakenly deleting a bracket { or ( would give rise to A LOT of errors, while the solution is a single button. I suffered for this. Even an unknown full stop mistakenly pressed would cause the entire program not to run or compile.
But I never gave up and I emerged victorious.

#**FUTURE IMPROVEMENTS**#
I would like to learn how I can clothe my naked, complicated code (to a naked, untrained eye) into a real cross-platform application that can be easier for a person to use than a command line, as if you're an engineer troubleshooting software via the command line.
This felt like playing God of War, one of my favorite games - nice and sweet but VERY tough and difficult.


Author: Simushi Mulowa.
Duration: 2 months.
Date: 9 February 2026.
